#version 450

#include ./particleinfo.shader
#include ./standard/rand.shader

layout(set = 1, binding = 0) uniform ParticleInfoBuffer
{
    uint ParticleCount;
    vec3 Padding_;
};

layout(set = 2, binding = 0) uniform ParticleBoundsBuffer
{
    vec3 BoundingBoxMin;
    float _padding0;
    vec3 BoundingBoxMax;
    float _padding1;
    vec3 ResetBoxMin;
    float _padding2;
    vec3 ResetBoxMax;
    float _padding3;
};


vec3 reset(uint index, vec3 position)
{
    return vec3(random(position.xy), random(position.yz), random(position.zx)) * (ResetBoxMax - ResetBoxMin) + ResetBoxMin;
}

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
void main()
{
    uint index = gl_GlobalInvocationID.x;
    if (index > ParticleCount)
    {
        return;
    }
    
    //TODO: if velocity is done here delta is nessesary as well?
    ParticleInfo particle = Particles[index];
    vec3 position = particle.Position + particle.Velocity;
    vec4 color = particle.Color + particle.ColorModifier;
    float livetime = particle.Livetime + particle.LivetimeModifer;

    if(livetime <= 0)
    {
        position = reset(index, position);
        color = particle.InitialColor;
        livetime = 1;
    }
    else if(position.x > BoundingBoxMax.x || position.y > BoundingBoxMax.y || position.z > BoundingBoxMax.z || position.x < BoundingBoxMin.x || position.y < BoundingBoxMin.y || position.z < BoundingBoxMin.z) 
    {
        position = reset(index, position);
        color = particle.InitialColor;
        livetime = 1;
    }

    Particles[index].Livetime = livetime;
    Particles[index].Color = color;
    Particles[index].Position = position;
}
