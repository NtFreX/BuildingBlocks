#version 450

#include ./particleinfo.shader

layout(set = 1, binding = 0) uniform ParticleInfoBuffer
{
    uint ParticleCount;
    vec3 Padding_;
};

layout(set = 2, binding = 0) uniform ParticleBoundsBuffer
{
    vec3 BoundingBoxMin;
    float _padding0;
    vec3 BoundingBoxMax;
    float _padding1;
    vec3 ResetBoxMin;
    float _padding2;
    vec3 ResetBoxMax;
    float _padding3;
};


layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

//float rand(vec2 co){
//    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);
//}

void main()
{
    uint index = gl_GlobalInvocationID.x;
    if (index > ParticleCount)
    {
        return;
    }
    
    //TODO: if velocity is done here speed is nessesary as well
    vec3 position = Particles[index].Position + Particles[index].Velocity;

    //TODO: use reset box
    if(position.x > BoundingBoxMax.x)
    {
        position.x = BoundingBoxMin.x;
    }
    if(position.y > BoundingBoxMax.y)
    {
        position.y = BoundingBoxMin.y;
    }
    if(position.z > BoundingBoxMax.z)
    {
        position.z = BoundingBoxMin.z;
    }    

    if(position.x < BoundingBoxMin.x)
    {
        position.x = BoundingBoxMax.x;
    }
    if(position.y < BoundingBoxMin.y)
    {
        position.y = BoundingBoxMax.y;
    }
    if(position.z < BoundingBoxMin.z)
    {
        position.z = BoundingBoxMax.z;
    }

    //TODO: make it random
    //if(position.x > BoundingBoxMax.x || position.y > BoundingBoxMax.y || position.z > BoundingBoxMax.z || position.x < BoundingBoxMin.x || position.y < BoundingBoxMin.y || position.z < BoundingBoxMin.z) 
    //{
    //    position = vec3(rand(position.xy), rand(position.yz), rand(position.zx)) * ResetBoxMax + ResetBoxMin;
    //}

    Particles[index].Position = position;
}
